<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Babylon.js using Havok</title>
    <!-- Babylon.js and Havok Physics -->
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #canvasZone {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #counterDisplay {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 20px;
        }

        @media screen and (orientation: landscape) {
            body {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            #canvasZone {
                width: 100vw;
                height: 100vh;
            }
        }
    </style>
</head>

<body>
    <div id="canvasZone">
        <canvas id="renderCanvas"></canvas>
        <div id="counterDisplay">Hits: 0</div>
    </div>
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true,
            disableWebGL2Support: false
        });

        // Counter variable
        let hitCounter = 0;

        

const createScene = async function () {
        const scene = new BABYLON.Scene(engine);

        // Camera setup
        const camera = new BABYLON.UniversalCamera("camera1", new BABYLON.Vector3(0, 5, -15), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.attachControl(canvas, true);

        // Zoom out animation
        const zoomOutAnimation = new BABYLON.Animation(
          "zoomOutAnimation",
          "position",
          60,
          BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
          BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );

        // Animation keyframes
        const zoomOutKeyframes = [
          {
            frame: 0,
            value: camera.position.clone(),
          },
          {
            frame: 100,
            value: camera.position.multiplyByFloats(1.25, 1.25, 2), // Zoom out by 25%
          },
        ];

        // Assign keyframes to animation
        zoomOutAnimation.setKeys(zoomOutKeyframes);

        // Attach animation to the camera
        camera.animations.push(zoomOutAnimation);

        // Run the animation
        scene.beginAnimation(camera, 0, 100, false);
        camera.detachControl(canvas);
      
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        light.intensity = 0.7;
        const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 0.5, segments: 32 }, scene);
        sphere.position.y = 4;
        const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 10, height: 10 }, scene);

        // Front Wall
        const courtWidth = 10;
        const frontWallHeight = 5;
        const courtLength = 10;

        var frontWall = BABYLON.MeshBuilder.CreateBox("frontWall", { width: courtWidth, height: frontWallHeight, depth: 0.2 }, scene);
        frontWall.position.z = courtLength / 2 - 0.1;
        frontWall.position.y = frontWallHeight / 2;

        var frontWallMaterial = new BABYLON.StandardMaterial("frontWallMaterial", scene);
        frontWallMaterial.diffuseTexture = new BABYLON.Texture("https://raw.githubusercontent.com/makeitcount89/app/c894a01088bc336ec52808193a55c1e94c2af44e/squash%20error%20tracker-min%20(1).png", scene);
        frontWall.material = frontWallMaterial;

        // Side Walls (White)
        const sideWallHeight = 5;
        const sideWallDepth = 0.2;

        var leftWall = BABYLON.MeshBuilder.CreateBox("leftWall", { width: sideWallDepth, height: sideWallHeight, depth: courtLength + 2 * sideWallDepth }, scene);
        leftWall.position.x = -courtWidth / 2 - sideWallDepth / 2;
        leftWall.position.y = sideWallHeight / 2;

        var rightWall = BABYLON.MeshBuilder.CreateBox("rightWall", { width: sideWallDepth, height: sideWallHeight, depth: courtLength + 2 * sideWallDepth }, scene);
        rightWall.position.x = courtWidth / 2 + sideWallDepth / 2;
        rightWall.position.y = sideWallHeight / 2;

        var sideWallMaterial = new BABYLON.StandardMaterial("sideWallMaterial", scene);
        sideWallMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
        leftWall.material = sideWallMaterial;
        rightWall.material = sideWallMaterial;

        // Initialize Havok Physics
        const havokInstance = await HavokPhysics();
        const hk = new BABYLON.HavokPlugin(true, havokInstance);
        scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), hk);

        // Create a sphere shape and the associated body.
        const sphereAggregate = new BABYLON.PhysicsAggregate(sphere, BABYLON.PhysicsShapeType.SPHERE, { mass: 1, restitution: 0.95 }, scene);

        // Create a static box shape for the ground.
        const groundAggregate = new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

        // Create a static box shape for the front wall.
        const frontWallAggregate = new BABYLON.PhysicsAggregate(frontWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

        // Create static box shapes for the side walls.
        const leftWallAggregate = new BABYLON.PhysicsAggregate(leftWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
        const rightWallAggregate = new BABYLON.PhysicsAggregate(rightWall, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

        // Variables for touch interaction
        let startingX;
        let startingY;
        let deltaX = 0;
        let deltaY = 0;

        // Handle touch interaction
        scene.onPointerObservable.add((pointerInfo) => {
          if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
            startingX = pointerInfo.event.clientX;
            startingY = pointerInfo.event.clientY;
          } else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE && startingX !== undefined && startingY !== undefined) {
            deltaX = startingX - pointerInfo.event.clientX;
            deltaY = startingY - pointerInfo.event.clientY;

            sphere.position.x -= deltaX * 0.1;
            sphere.position.z += deltaY * 0.1;

            startingX = pointerInfo.event.clientX;
            startingY = pointerInfo.event.clientY;
          } else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERUP) {
            startingX = undefined;
            startingY = undefined;

            // Check if the ball hits the front wall
            if (sphere.intersectsMesh(frontWall, false)) {
              hitCounter++;
              // Update the counter display
              updateCounterDisplay();
            }

              // Inside the POINTERMOVE block
            const smoothness = 0.2;
            sphere.position.x = BABYLON.Scalar.Lerp(sphere.position.x, sphere.position.x - deltaX * 0.1, smoothness);
            sphere.position.z = BABYLON.Scalar.Lerp(sphere.position.z, sphere.position.z + deltaY * 0.1, smoothness);

            // Inside the POINTERUP block
            if (sphere.intersectsMesh(frontWall, false)) {
                hitCounter++;
                updateCounterDisplay();

                // Visual feedback example: Change color for a short duration
                const originalColor = frontWall.material.diffuseColor.clone();
                frontWall.material.diffuseColor = BABYLON.Color3.Red();
                setTimeout(() => {
                    frontWall.material.diffuseColor = originalColor;
                }, 200);
            }

            const swipeImpulse = new BABYLON.Vector3(deltaX * 0.1, 0, deltaY * 0.1);
            sphereAggregate.body.applyImpulse(swipeImpulse, sphere.getAbsolutePosition());
            sphereAggregate.body.setLinearDamping(0.1);

            deltaX = 0;
            deltaY = 0;
        });

        return scene;
    };

    // Function to update the counter display
    function updateCounterDisplay() {
        const counterDisplay = document.getElementById("counterDisplay");
        if (counterDisplay) {
            counterDisplay.innerHTML = `Hits: ${hitCounter}`;
        }
    }

    createScene().then((scene) => {
        engine.runRenderLoop(() => {
            if (scene) {
                scene.render();
            }
        });
    });

    // Resize
    window.addEventListener("resize", () => {
        engine.resize();
    });
    </script>
</body>

</html>

      
